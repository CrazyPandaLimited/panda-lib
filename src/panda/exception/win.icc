// adopted from https://github.com/boostorg/stacktrace/tree/develop/include/boost/stacktrace/detail

#include <iostream>
#include <windows.h>
#include <cxxabi.h>
#include "dbgeng.h"

__CRT_UUID_DECL(IDebugClient,0x27fe5639,0x8407,0x4f47,0x83,0x64,0xee,0x11,0x8f,0xb0,0x8a,0xc8)
__CRT_UUID_DECL(IDebugControl,0x5182e668,0x105e,0x416e,0xad,0x92,0x24,0xef,0x80,0x04,0x24,0xba)
__CRT_UUID_DECL(IDebugSymbols,0x8c31e98c,0x983a,0x48a5,0x90,0x16,0x6f,0xe5,0xd6,0x67,0xa9,0x50)


namespace panda {


class com_global_initer {
    bool _ok;

public:
    com_global_initer() noexcept
        : _ok(false)
    {
        // COINIT_MULTITHREADED means that we must serialize access to the objects manually.
        // This is the fastest way to work. If user calls CoInitializeEx before us - we
        // can end up with other mode (which is OK for us).
        //
        // If we call CoInitializeEx befire user - user may end up with different mode, which is a problem.
        // So we need to call that initialization function as late as possible.
        auto res = ::CoInitializeEx(0, COINIT_MULTITHREADED);
        _ok = (res == S_OK || res == S_FALSE);
    }
    com_global_initer(const com_global_initer&) = delete;

    ~com_global_initer() noexcept {
        if (_ok) { ::CoUninitialize(); }
    }
};

template <class T>
class com_holder {
    T* holder_;

public:
    com_holder(const com_global_initer&) noexcept : holder_(nullptr) {}

    T* operator->() const noexcept { return holder_; }

    void** to_void_ptr_ptr() noexcept {
        return reinterpret_cast<void**>(&holder_);
    }

    bool is_inited() const noexcept { return !!holder_; }

    ~com_holder() noexcept { if (holder_) { holder_->Release(); } }
};

class debugging_symbols{
    debugging_symbols(const debugging_symbols&) = delete;

    static void try_init_com(com_holder< ::IDebugSymbols>& idebug, const com_global_initer& com) noexcept {
        com_holder< ::IDebugClient> iclient(com);
        if (S_OK != ::DebugCreate(__uuidof(IDebugClient), iclient.to_void_ptr_ptr())) {
            return;
        }

        com_holder< ::IDebugControl> icontrol(com);
        const bool res0 = (S_OK == iclient->QueryInterface(
            __uuidof(IDebugControl),
            icontrol.to_void_ptr_ptr()
        ));
        if (!res0) {
            return;
        }

        const bool res1 = (S_OK == iclient->AttachProcess(
            0,
            ::GetCurrentProcessId(),
            DEBUG_ATTACH_NONINVASIVE | DEBUG_ATTACH_NONINVASIVE_NO_SUSPEND
        ));
        if (!res1) {
            return;
        }

        if (S_OK != icontrol->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE)) {
            return;
        }

        // No cheking: QueryInterface sets the output parameter to NULL in case of error.
        iclient->QueryInterface(__uuidof(IDebugSymbols), idebug.to_void_ptr_ptr());
    }


    static com_holder< ::IDebugSymbols>& get_thread_local_debug_inst() noexcept {
        // [class.mfct]: A static local variable or local type in a member function always refers to the same entity, whether
        // or not the member function is inline.
        static thread_local com_global_initer com;
        static thread_local com_holder< ::IDebugSymbols> idebug(com);

        if (!idebug.is_inited()) {
            try_init_com(idebug, com);
        }

        return idebug;
    }

    com_holder< ::IDebugSymbols>& idebug_;
public:
    debugging_symbols() noexcept : idebug_( get_thread_local_debug_inst() ) {}

    bool is_inited() const noexcept { return idebug_.is_inited();  }

    void gather(const void* addr, Stackframe& f) const noexcept {
        if (!is_inited()) { return; }
        const ULONG64 offset = reinterpret_cast<ULONG64>(addr);

        // get name and dll
        string fqn;
        char buff[256] = {0};
        buff[0] = '\0';
        ULONG size = 0;
        bool res = (S_OK == idebug_->GetNameByOffset(offset, buff, sizeof(buff), &size, 0 ));

        if (!res && size != 0) {
            fqn.resize(size);
            res = (S_OK == idebug_->GetNameByOffset(offset, fqn.buf(), size,  &size, 0));
            if (res) { fqn.length(size - 1); }
        } else if (res) {
            fqn.assign(buff, size - 1);
        }
        if (res) {
            //std::cout << "fqn: " << buff << "\n";

            auto delimiter = fqn.find_first_of('!');
            if (delimiter == string::npos) { f.library = fqn; } // can't get name
            else {
                auto dll     = fqn.substr(0, delimiter);
                auto mangled = fqn.substr(delimiter + 1);

                auto demangled = mangled;
                if (mangled.size() > 2 && (mangled[0] == '_') && (mangled[1] == 'Z')) {
                    int status;
                    char* d = abi::__cxa_demangle(mangled.c_str(), nullptr, nullptr, &status);
                    if (d) {
                        demangled = d;
                        free(d);
                    }
                }
                f.mangled_name = mangled;
                f.name = demangled;
                f.library = dll;
            }
        }

        // get source file & line_no ; actually does not work on mingw
        buff[0] = '\0';
        ULONG line_no = 0;
        string file;
        res = (S_OK == idebug_->GetLineByOffset(reinterpret_cast<ULONG64>(addr), &line_no, buff, sizeof(buff), &size, 0));
        //std::cout << "l =" << line_no << "\n";
        if (!res && size != 0) {
            file.resize(size);
            res = (S_OK == idebug_->GetLineByOffset(reinterpret_cast<ULONG64>(addr), &line_no, file.buf(), size, &size, 0));
        } else if (res) {
            file = buff;
        }
        if (res) {
            file.length(size - 1);
            f.line_no = line_no;
            f.file = file;
        }

        f.address = reinterpret_cast<uint64_t>(addr);
    }
};

static RawTraceProducer get_default_raw_producer () noexcept {
    return [](void** ptr, int sz) -> int {
        auto r = ::CaptureStackBackTrace(2, static_cast<unsigned long>(sz), ptr, nullptr);
        return r;
    };
}

static StackframePtr as_frame(const void* ip) noexcept {
    StackframePtr r{};
    debugging_symbols idebug;
    if (!idebug.is_inited()) { return r; }

    r = StackframePtr(new Stackframe());
    idebug.gather(ip, *r);
    return r;
}

static BacktraceProducer get_default_bt_producer () noexcept {
    return [](const RawTrace& traces) -> iptr<BacktraceInfo> {
        std::vector<StackframePtr> frames;
        for(auto ip: traces) {
            auto frame = as_frame(ip);
            if (frame) { frames.emplace_back(std::move(frame)); }
        }
        return new BacktraceInfo(std::move(frames));
    };
}

}
